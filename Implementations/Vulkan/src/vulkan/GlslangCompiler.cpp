#include "DisarrayPCH.hpp"

#include <SPIRV/GlslangToSpv.h>
#include <SPIRV/SpvTools.h>
#include <glslang/MachineIndependent/Versions.h>
#include <glslang/Public/ResourceLimits.h>
#include <glslang/Public/ShaderLang.h>

#include <exception>

#include "core/Collections.hpp"
#include "core/Ensure.hpp"
#include "core/Formatters.hpp"
#include "core/Log.hpp"
#include "core/Types.hpp"
#include "core/filesystem/FileIO.hpp"
#include "graphics/Shader.hpp"
#include "graphics/ShaderCompiler.hpp"
#include "vulkan/IncludeDirectoryIncluder.hpp"

namespace Disarray::Runtime {

static auto was_initialised() -> bool&
{
	static bool initialised { false };
	return std::ref(initialised);
}

struct Detail::CompilerIntrinsics {
	Scope<IncludeDirectoryIncluder> include_dir_includer = make_scope<IncludeDirectoryIncluder>("Assets/Shaders/Include");

	static auto to_glslang_type(ShaderType type) -> EShLanguage
	{
		switch (type) {
		case ShaderType::Vertex:
			return EShLangVertex;
		case ShaderType::Fragment:
			return EShLangFragment;
		case ShaderType::Compute:
			return EShLangCompute;
		default:
			unreachable("Incorrect mapping of shader types.");
		}
	}
};

auto ShaderCompiler::Deleter::operator()(Detail::CompilerIntrinsics* ptr) -> void { delete ptr; }

auto ShaderCompiler::compile(const std::filesystem::path& path_to_shader, ShaderType type) -> std::vector<std::uint32_t>
{
	ensure(was_initialised(), "Compiler was not initialised");

	const TBuiltInResource* resources = GetDefaultResources();

	auto glslang_type = Detail::CompilerIntrinsics::to_glslang_type(type);

	std::unique_ptr<glslang::TShader> shader { new glslang::TShader { glslang_type } };

	std::string output;
	if (!FS::read_from_file(path_to_shader.string(), output)) {
		DISARRAY_LOG_ERROR("ShaderCompiler", "Could not read shader: {}", path_to_shader);
		throw CouldNotOpenStreamException { fmt::format("Could not read shader: {}", path_to_shader) };
	}
	add_include_extension(output);

	std::array sources = { output.c_str() };
	shader->setStrings(sources.data(), 1);

	// Use appropriate Vulkan version
	glslang::EShTargetClientVersion target_api_version = glslang::EShTargetVulkan_1_3;
	shader->setEnvClient(glslang::EShClientVulkan, target_api_version);

	glslang::EShTargetLanguageVersion target_spirv_version = glslang::EShTargetSpv_1_6;
	shader->setEnvTarget(glslang::EshTargetSpv, target_spirv_version);

	shader->setEntryPoint("main");
	const int default_version = 460;
	const bool forward_compatible = false;
	EProfile default_profile = ECoreProfile;

	std::string preprocessed_str;
	glslang::TShader::ForbidIncluder includer {};
	if (!shader->preprocess(resources, default_version, default_profile, false, forward_compatible, EShMsgDefault, &preprocessed_str, includer)) {
		DISARRAY_LOG_ERROR("ShaderCompiler", "Failed to preprocess shader: {}. Info:{}", path_to_shader.string(), shader->getInfoLog());
		return {};
	}

	std::array strings { preprocessed_str.c_str() };
	shader->setStrings(strings.data(), 1);

	if (!shader->parse(resources, default_version, default_profile, false, forward_compatible, EShMsgDefault)) {
		DISARRAY_LOG_ERROR("ShaderCompiler", "Failed to parse shader: {}. Info: {}", path_to_shader.string(), shader->getInfoLog());
		return {};
	}

	glslang::TProgram program;
	program.addShader(shader.get());
	if (!program.link(EShMsgDefault)) {
		DISARRAY_LOG_ERROR("ShaderCompiler", "Failed to link shader: {}. Info:{}", path_to_shader.string(), program.getInfoLog());
		return {};
	}

	// Convert the intermediate generated by glslang to Spir-V
	glslang::TIntermediate& intermediate_ref = *(program.getIntermediate(shader->getStage()));
	std::vector<uint32_t> spirv;
	glslang::SpvOptions options {};
	options.validate = true;
	options.generateDebugInfo = true;
	spv::SpvBuildLogger logger;
	glslang::GlslangToSpv(intermediate_ref, spirv, &logger, &options);

	if (const auto all_messages = logger.getAllMessages(); !all_messages.empty()) {
		DISARRAY_LOG_INFO("ShaderCompiler", "SpvBuildLogger messages  \n{}\n", logger.getAllMessages());
	}

	return spirv;
}

auto ShaderCompiler::try_compile(const std::filesystem::path& path, Disarray::ShaderType type) -> std::pair<bool, Code>
{
	try {
		auto compiled = compile(path, type);
		if (compiled.empty()) {
			return { false, {} };
		}
		return { true, compiled };

	} catch (const BaseException& exc) {
		DISARRAY_LOG_ERROR("ShaderCompiler::try_compile", "Error: {}", exc.what());
		return { false, {} };
	} catch (const std::exception& exc) {
		DISARRAY_LOG_ERROR("ShaderCompiler::try_compile", "Error: {}", exc.what());
		return { false, {} };
	}
}

void ShaderCompiler::initialize()
{
	if (!was_initialised()) {
		glslang::InitializeProcess();
		was_initialised() = true;
	}
}
void ShaderCompiler::destroy()
{
	if (was_initialised()) {
		glslang::FinalizeProcess();
		was_initialised() = false;
	}
}

void ShaderCompiler::add_include_extension(std::vector<char>& glsl_code)
{
	static constexpr std::string_view extension = "\n#version 460\n#extension GL_GOOGLE_include_directive:require\n";
	std::string output;
	output += extension;
	for (char character : glsl_code) {
		output += character;
	}
	output.shrink_to_fit();

	glsl_code = { output.begin(), output.end() };
}

static auto replace(std::string& output, const std::string_view from, const std::string& replacement) -> bool
{
	size_t start_pos = output.find(from);
	if (start_pos == std::string::npos) {
		return false;
	}
	output.replace(start_pos, from.length(), replacement.c_str());
	return true;
}

static auto get_includes() -> const auto&
{
	static const Collections::StringViewMap<std::string> includes = []() {
		Collections::StringViewMap<std::string> inc {};
		inc["PC.glsl"] = {};
		if (!FS::read_from_file("Assets/Shaders/Include/PC.glsl", inc["PC.glsl"])) {
			DISARRAY_LOG_ERROR("ShaderCompiler", "Could not populate include map with file: {}", "PC.glsl");
		}
		inc["UBO.glsl"] = {};
		if (!FS::read_from_file("Assets/Shaders/Include/UBO.glsl", inc["UBO.glsl"])) {
			DISARRAY_LOG_ERROR("ShaderCompiler", "Could not populate include map with file: {}", "UBO.glsl");
		}
		inc["CameraUBO.glsl"] = {};
		if (!FS::read_from_file("Assets/Shaders/Include/CameraUBO.glsl", inc["CameraUBO.glsl"])) {
			DISARRAY_LOG_ERROR("ShaderCompiler", "Could not populate include map with file: {}", "CameraUBO.glsl");
		}
		inc["PointLight.glsl"] = {};
		if (!FS::read_from_file("Assets/Shaders/Include/PointLight.glsl", inc["PointLight.glsl"])) {
			DISARRAY_LOG_ERROR("ShaderCompiler", "Could not populate include map with file: {}", "PointLight.glsl");
		}

		return inc;
	}();

	return includes;
}

static auto check_and_replace(auto& io_string, const std::string_view to_find)
{
	if (io_string.find(fmt::format("#include \"{}\"\n", to_find)) == std::string::npos) {
		return;
	}

	auto include = fmt::format("#include \"{}\"\n", to_find);
	const auto include_string = get_includes().at(to_find);

	replace(io_string, include, fmt::format("\n{}\n", include_string));
}

void ShaderCompiler::add_include_extension(std::string& glsl_code)
{
	ensure(glsl_code.find("#version") == std::string::npos, "Shader has a #version directive");
	static constexpr std::string_view extension = "#version 460\n";
	glsl_code.insert(0, extension);

	using namespace std::string_view_literals;
	std::array includes = { "PC.glsl"sv, "CameraUBO.glsl"sv, "PointLight.glsl"sv, "UBO.glsl"sv };
	Collections::for_each(includes, [&code = glsl_code](const auto& value) { check_and_replace(code, value); });
}

ShaderCompiler::ShaderCompiler()
	: compiler_data(make_scope<Detail::CompilerIntrinsics, Deleter>())
{
}

} // namespace Disarray::Runtime
