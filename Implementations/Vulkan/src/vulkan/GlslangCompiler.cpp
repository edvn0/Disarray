#include "DisarrayPCH.hpp"

#include <glslang/Public/ShaderLang.h>

#include <exception>

#include "SPIRV/GlslangToSpv.h"
#include "SPIRV/SpvTools.h"
#include "core/Ensure.hpp"
#include "core/Formatters.hpp"
#include "core/Log.hpp"
#include "core/Types.hpp"
#include "core/filesystem/FileIO.hpp"
#include "glslang/MachineIndependent/Versions.h"
#include "glslang/Public/ResourceLimits.h"
#include "graphics/Shader.hpp"
#include "graphics/ShaderCompiler.hpp"

namespace Disarray::Runtime {

struct Detail::CompilerIntrinsics {
	static auto to_glslang_type(ShaderType type) -> EShLanguage
	{
		switch (type) {
		case ShaderType::Vertex:
			return EShLangVertex;
		case ShaderType::Fragment:
			return EShLangFragment;
		case ShaderType::Compute:
			return EShLangCompute;
		default:
			unreachable("Incorrect mapping of shader types.");
		}
	}
};

auto Detail::script_deleter(Detail::CompilerIntrinsics* ptr) -> void { delete ptr; }

auto ShaderCompiler::compile(const std::filesystem::path& path_to_shader, ShaderType type) -> std::vector<std::uint32_t>
{
	const TBuiltInResource* resources = GetDefaultResources();

	auto glslang_type = Detail::CompilerIntrinsics::to_glslang_type(type);

	std::unique_ptr<glslang::TShader> shader { new glslang::TShader { glslang_type } };

	struct IncludeDirectoryIncluder : public glslang::TShader::Includer {
		IncludeDirectoryIncluder(std::filesystem::path dir)
			: include_directory(std::move(dir))
		{
		}
		std::filesystem::path include_directory;

		void releaseInclude(IncludeResult* result) override { Log::info("IncludeDirectoryIncluder", "Current header: {}", result->headerName); }
	};

	Scope<IncludeDirectoryIncluder> include_dir_includer = make_scope<IncludeDirectoryIncluder>("Assets/Shaders/Include");

	Log::info("ShaderCompiler", "Compiling shader '{}' with type: '{}'", path_to_shader, type);

	std::vector<char> output;
	FS::read_from_file(path_to_shader.string(), output);

	std::array<char*, 1> sources = { output.data() };
	shader->setStrings(sources.data(), 1);

	// Use appropriate Vulkan version
	glslang::EShTargetClientVersion target_api_version = glslang::EShTargetVulkan_1_3;
	shader->setEnvClient(glslang::EShClientVulkan, target_api_version);

	glslang::EShTargetLanguageVersion target_spirv_version = glslang::EShTargetSpv_1_3;
	shader->setEnvTarget(glslang::EshTargetSpv, target_spirv_version);

	shader->setEntryPoint("main"); // We can specify a different entry point

	// int defaultVersion = 110, // use 100 for ES environment, overridden by #version in shader
	const int default_version = 450;
	const bool forward_compatible = false;
	const auto message_flags = (EShMessages)(EShMsgSpvRules | EShMsgVulkanRules);
	EProfile default_profile = ENoProfile; // NOTE: Only for desktop, before profiles showed up!

	std::string preprocessed_str;
	if (!shader->preprocess(
			resources, default_version, default_profile, false, forward_compatible, message_flags, &preprocessed_str, *include_dir_includer)) {
		Log::error("ShaderCompiler", "Failed to preprocess shader: {}", shader->getInfoLog());
		ensure(false);
	}
	std::array<const char*, 1> preprocessed_sources = { preprocessed_str.c_str() };
	shader->setStrings(preprocessed_sources.data(), 1);

	if (!shader->parse(resources, default_version, default_profile, false, forward_compatible, message_flags)) {
		Log::error("ShaderCompiler", "Failed to parse shader: {}", shader->getInfoLog());
		ensure(false);
	}

	glslang::TProgram program;
	program.addShader(shader.get());
	if (!program.link(message_flags)) {
		Log::error("ShaderCompiler", "Failed to link shader: {}", program.getInfoLog());
		ensure(false);
	}

	// Convert the intermediate generated by glslang to Spir-V
	glslang::TIntermediate& intermediate_ref = *(program.getIntermediate(shader->getStage()));
	std::vector<uint32_t> spirv;
	glslang::SpvOptions options {};
	options.validate = true;
	// TODO: We can also provide a logger to glslang.
	// glslang::spv::SpvBuildLogger logger;
	// glslang::GlslangToSpv(intermediateRef, spirv, &logger, &options);
	glslang::GlslangToSpv(intermediate_ref, spirv, &options);

	return spirv;
}
void ShaderCompiler::initialize() { glslang::InitializeProcess(); }
void ShaderCompiler::destroy() { glslang::FinalizeProcess(); }

} // namespace Disarray::Runtime
