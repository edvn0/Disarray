#include "DisarrayPCH.hpp"

#include <SPIRV/GlslangToSpv.h>
#include <SPIRV/SpvTools.h>
#include <glslang/MachineIndependent/Versions.h>
#include <glslang/Public/ResourceLimits.h>
#include <glslang/Public/ShaderLang.h>

#include <exception>

#include "core/Ensure.hpp"
#include "core/Formatters.hpp"
#include "core/Log.hpp"
#include "core/Types.hpp"
#include "core/filesystem/FileIO.hpp"
#include "graphics/Shader.hpp"
#include "graphics/ShaderCompiler.hpp"
#include "vulkan/IncludeDirectoryIncluder.hpp"

namespace Disarray::Runtime {

struct Detail::CompilerIntrinsics {
	static auto to_glslang_type(ShaderType type) -> EShLanguage
	{
		switch (type) {
		case ShaderType::Vertex:
			return EShLangVertex;
		case ShaderType::Fragment:
			return EShLangFragment;
		case ShaderType::Compute:
			return EShLangCompute;
		default:
			unreachable("Incorrect mapping of shader types.");
		}
	}
};

auto Detail::script_deleter(Detail::CompilerIntrinsics* ptr) -> void { delete ptr; }

auto ShaderCompiler::compile(const std::filesystem::path& path_to_shader, ShaderType type) -> std::vector<std::uint32_t>
{
	const TBuiltInResource* resources = GetDefaultResources();

	auto glslang_type = Detail::CompilerIntrinsics::to_glslang_type(type);

	std::unique_ptr<glslang::TShader> shader { new glslang::TShader { glslang_type } };

	Scope<IncludeDirectoryIncluder> include_dir_includer = make_scope<IncludeDirectoryIncluder>("Assets/Shaders/Include");

	DISARRAY_LOG_INFO("ShaderCompiler", "Compiling shader '{}' with type: '{}'", path_to_shader, type);

	std::vector<char> output;
	FS::read_from_file(path_to_shader.string(), output);
	add_include_extension(output);

	std::array<char*, 1> sources = { output.data() };
	shader->setStrings(sources.data(), 1);

	// Use appropriate Vulkan version
	glslang::EShTargetClientVersion target_api_version = glslang::EShTargetVulkan_1_3;
	shader->setEnvClient(glslang::EShClientVulkan, target_api_version);

	glslang::EShTargetLanguageVersion target_spirv_version = glslang::EShTargetSpv_1_3;
	shader->setEnvTarget(glslang::EshTargetSpv, target_spirv_version);

	shader->setEntryPoint("main"); // We can specify a different entry point
	// int defaultVersion = 110, // use 100 for ES environment, overridden by #version in shader
	const int default_version = 450;
	const bool forward_compatible = false;
	const auto message_flags = (EShMessages)(EShMsgSpvRules | EShMsgVulkanRules);
	EProfile default_profile = ENoProfile; // NOTE: Only for desktop, before profiles showed up!

	std::string preprocessed_str;
	if (!shader->preprocess(
			resources, default_version, default_profile, false, forward_compatible, message_flags, &preprocessed_str, *include_dir_includer)) {
		DISARRAY_LOG_ERROR("ShaderCompiler", "Failed to preprocess shader: {}", shader->getInfoLog());
		ensure(false);
	}
	std::array<const char*, 1> preprocessed_sources = { preprocessed_str.c_str() };
	shader->setStrings(preprocessed_sources.data(), 1);

	if (!shader->parse(resources, default_version, default_profile, false, forward_compatible, message_flags)) {
		DISARRAY_LOG_ERROR("ShaderCompiler", "Failed to parse shader: {}", shader->getInfoLog());
		ensure(false);
	}

	glslang::TProgram program;
	program.addShader(shader.get());
	if (!program.link(message_flags)) {
		DISARRAY_LOG_ERROR("ShaderCompiler", "Failed to link shader: {}", program.getInfoLog());
		ensure(false);
	}

	// Convert the intermediate generated by glslang to Spir-V
	glslang::TIntermediate& intermediate_ref = *(program.getIntermediate(shader->getStage()));
	std::vector<uint32_t> spirv;
	glslang::SpvOptions options {};
	options.validate = true;
	// TODO: We can also provide a logger to glslang.
	// glslang::spv::SpvBuildLogger logger;
	// glslang::GlslangToSpv(intermediateRef, spirv, &logger, &options);
	glslang::GlslangToSpv(intermediate_ref, spirv, &options);

	return spirv;
}
void ShaderCompiler::initialize() { glslang::InitializeProcess(); }
void ShaderCompiler::destroy() { glslang::FinalizeProcess(); }

void ShaderCompiler::add_include_extension(std::vector<char>& glsl_code)
{
	static constexpr std::string_view extension = "\n#extension GL_GOOGLE_include_directive: require\n";
	static constexpr std::string_view version = "#version 450\n";
	std::string output;
	output.reserve(glsl_code.size());
	for (char code_character : glsl_code) {
		output.push_back(code_character);
	}

	auto found = output.find(version);
	output.insert(found + version.size() + 1, extension);

	glsl_code.clear();
	for (char character : output) {
		glsl_code.push_back(character);
	}
}

} // namespace Disarray::Runtime
