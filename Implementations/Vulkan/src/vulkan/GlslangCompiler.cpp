#include "DisarrayPCH.hpp"

#include <SPIRV/GlslangToSpv.h>
#include <SPIRV/SpvTools.h>
#include <glslang/MachineIndependent/Versions.h>
#include <glslang/Public/ResourceLimits.h>
#include <glslang/Public/ShaderLang.h>

#include <exception>

#include "core/Ensure.hpp"
#include "core/Formatters.hpp"
#include "core/Log.hpp"
#include "core/Types.hpp"
#include "core/filesystem/FileIO.hpp"
#include "graphics/Shader.hpp"
#include "graphics/ShaderCompiler.hpp"
#include "vulkan/IncludeDirectoryIncluder.hpp"

namespace Disarray::Runtime {

static auto was_initialised() -> bool&
{
	static bool initialised { false };
	return std::ref(initialised);
}

struct Detail::CompilerIntrinsics {
	Scope<IncludeDirectoryIncluder> include_dir_includer = make_scope<IncludeDirectoryIncluder>("Assets/Shaders/Include");

	static auto to_glslang_type(ShaderType type) -> EShLanguage
	{
		switch (type) {
		case ShaderType::Vertex:
			return EShLangVertex;
		case ShaderType::Fragment:
			return EShLangFragment;
		case ShaderType::Compute:
			return EShLangCompute;
		default:
			unreachable("Incorrect mapping of shader types.");
		}
	}
};

auto Detail::data_deleter(Detail::CompilerIntrinsics* ptr) -> void
{
	DISARRAY_LOG_DEBUG("Detail::data_deleter", "Deleted compiler_intrinsics ptr at: {}", fmt::ptr(ptr));

	delete ptr;
}

auto ShaderCompiler::compile(const std::filesystem::path& path_to_shader, ShaderType type) -> std::vector<std::uint32_t>
{
	ensure(was_initialised(), "Compiler was not initialised");

	const TBuiltInResource* resources = GetDefaultResources();

	auto glslang_type = Detail::CompilerIntrinsics::to_glslang_type(type);

	std::unique_ptr<glslang::TShader> shader { new glslang::TShader { glslang_type } };
	DISARRAY_LOG_INFO("ShaderCompiler", "Compiling shader '{}' with type: '{}'", path_to_shader, type);

	std::string output;
	if (!FS::read_from_file(path_to_shader.string(), output)) {
		DISARRAY_LOG_ERROR("ShaderCompiler", "Could not read shader: {}", path_to_shader);
		throw CouldNotOpenStreamException { fmt::format("Could not read shader: {}", path_to_shader) };
	}
	add_include_extension(output);

	std::array sources = { output.c_str() };
	shader->setStrings(sources.data(), 1);

	// Use appropriate Vulkan version
	glslang::EShTargetClientVersion target_api_version = glslang::EShTargetVulkan_1_3;
	shader->setEnvClient(glslang::EShClientVulkan, target_api_version);

	glslang::EShTargetLanguageVersion target_spirv_version = glslang::EShTargetSpv_1_6;
	shader->setEnvTarget(glslang::EshTargetSpv, target_spirv_version);

	shader->setEntryPoint("main");
	const int default_version = 460;
	const bool forward_compatible = false;
	EProfile default_profile = ECoreProfile;

	std::string preprocessed_str;
	if (!shader->preprocess(resources, default_version, default_profile, false, forward_compatible, EShMsgDefault, &preprocessed_str,
			*compiler_data->include_dir_includer)) {
		DISARRAY_LOG_ERROR("ShaderCompiler", "Failed to preprocess shader: {}. Info:{}", path_to_shader.string(), shader->getInfoLog());
		return {};
	}

	std::array strings { preprocessed_str.c_str() };
	shader->setStrings(strings.data(), 1);

	if (!shader->parse(resources, default_version, default_profile, false, forward_compatible, EShMsgDefault)) {
		DISARRAY_LOG_ERROR("ShaderCompiler", "Failed to parse shader: {}. Info: {}", path_to_shader.string(), shader->getInfoLog());
		return {};
	}

	glslang::TProgram program;
	program.addShader(shader.get());
	if (!program.link(EShMsgDefault)) {
		DISARRAY_LOG_ERROR("ShaderCompiler", "Failed to link shader: {}. Info:{}", path_to_shader.string(), program.getInfoLog());
		return {};
	}

	program.dumpReflection();

	// Convert the intermediate generated by glslang to Spir-V
	glslang::TIntermediate& intermediate_ref = *(program.getIntermediate(shader->getStage()));
	std::vector<uint32_t> spirv;
	glslang::SpvOptions options {};
	options.validate = true;
	options.generateDebugInfo = true;
	spv::SpvBuildLogger logger;
	glslang::GlslangToSpv(intermediate_ref, spirv, &logger, &options);

	return spirv;
}

auto ShaderCompiler::try_compile(const std::filesystem::path& path, Disarray::ShaderType type) -> std::pair<bool, Code>
{
	try {
		auto compiled = compile(path, type);
		if (compiled.empty()) {
			return { false, {} };
		}
		return { true, compiled };

	} catch (const BaseException& exc) {
		DISARRAY_LOG_ERROR("ShaderCompiler::try_compile", "Error: {}", exc.what());
		return { false, {} };
	} catch (const std::exception& exc) {
		DISARRAY_LOG_ERROR("ShaderCompiler::try_compile", "Error: {}", exc.what());
		return { false, {} };
	}
}

void ShaderCompiler::initialize()
{
	if (!was_initialised()) {
		glslang::InitializeProcess();
		was_initialised() = true;
	}
}
void ShaderCompiler::destroy()
{
	if (was_initialised()) {
		glslang::FinalizeProcess();
		was_initialised() = false;
	}
}

void ShaderCompiler::add_include_extension(std::vector<char>& glsl_code)
{
	static constexpr std::string_view extension = "\n#version 460\n#extension GL_GOOGLE_include_directive:require\n";
	std::string output;
	output += extension;
	for (char character : glsl_code) {
		output += character;
	}
	output.shrink_to_fit();

	glsl_code = { output.begin(), output.end() };
}

void ShaderCompiler::add_include_extension(std::string& glsl_code)
{
	ensure(glsl_code.find("#version") == std::string::npos, "Shader has a #version directive");
	static constexpr std::string_view extension = "#version 450\n#extension GL_GOOGLE_include_directive: require\n";
	glsl_code.insert(0, extension);
}

ShaderCompiler::ShaderCompiler()
	: compiler_data(make_scope<Detail::CompilerIntrinsics, Deleter>())
{
}

} // namespace Disarray::Runtime
